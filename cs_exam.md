**1. Состав языка C#. Типы данных C#.**

*   **Состав языка C#:**
    *   **Алфавит:** Включает прописные и строчные латинские буквы, буквы национальных алфавитов (в том числе кириллицу), арабские цифры (0-9), шестнадцатеричные цифры (A-F), специальные знаки (`"` `{` `}` `,` `|` `;` `[` `]` `(` `)` `+` `-` `/` `%` `*` `.` `\` `'` `:` `?` `<` `=` `>` `!` `&` `~` `^` `@` `_`) и пробельные символы (пробел, табуляция, перевод строки).
    *   **Идентификаторы (Identifiers):** Используются для именования программных элементов (переменных, констант, методов, классов и т.д.).  Могут содержать буквы, цифры и символ подчеркивания.  Регистр букв имеет значение ( `myname`, `myName` и `MyName` – разные идентификаторы).  Первый символ – буква или знак подчеркивания.

*   **Типы данных C#:** Делятся на *типы-значения (value types)* и *ссылочные типы (reference types)*.
    *   **Value Types:** Переменные хранят непосредственно значение. При присваивании происходит копирование значения. Примеры включают `int`, `bool`, `byte`, `short`, `ushort`, `uint`, `long`, `ulong`, `float`, `double`, `char`, `decimal`, `enum`.
        *   Пример: `int i = 25;`
    *   **Reference Types:** Переменные хранят ссылку на область памяти (в куче), где находится значение. При присваивании копируется ссылка. Примеры включают `object`, `string`, `class`, массивы.
        *   Пример: `string s = "John";`
            `object z=new object();`
* `object` является базовым типом для всех типов.

**2. Организация ввода-вывода данных. Форматирование.**

*   **Вывод данных:**
    *   `Console.WriteLine()` используется для вывода на консоль. Может принимать один аргумент (выводимое значение) или несколько с использованием форматирования:
        *   `Console.WriteLine(x);` // Вывод значения переменной `x`
        *   `Console.WriteLine("x=" + x + "y=" + y);` // Конкатенация строк и значений.
        *   `Console.WriteLine("x={0} y={1}", x, y);` // Форматированный вывод: значения `x` и `y` подставляются вместо `{0}` и `{1}`.
    * Поддерживаются управляющие последовательности, например, `\n` для новой строки.

*   **Ввод данных:**
    *   `Console.ReadLine()` считывает строку, введенную пользователем с консоли.

        ```csharp
        static void Main()
        {
          string s = Console.ReadLine();
          Console.WriteLine(s);
        }
        ```

**3. Операции и выражения в C#. Операторы ветвления.**

*   **Операции:**
    *   **Арифметические:** `+` (сложение), `-` (вычитание, унарный минус), `*` (умножение), `/` (деление), `%` (остаток от деления).
    *   **Инкремент/декремент:** `++` (увеличение), `--` (уменьшение). Префиксная (`++i`) и постфиксная (`i++`) формы.
    *   **Присваивание:** `=`, `+=`, `-=`, `*=`, `/=`, `%=`.
    *   **Отношения:** `<`, `<=`, `>`, `>=`, `==` (равно), `!=` (не равно). Результат типа `bool`.
    *   **Логические:** `&&` (И), `||` (ИЛИ), `!` (НЕ).
    *   **Условная операция:** `(condition) ? expression1 : expression2`
    *   **Явное преобразование типа:** `(type) expression;`
    *   **new**: создание объекта.

*   **Выражения:** Состоят из операндов, операций и скобок.  Определяют вычисление значения.  Примеры: `(a + 0.12)/6`, `x && y || !z`.

*   **Операторы ветвления:**
    *   **`if` (сокращенная форма):**

        ```csharp
        if (condition) statement;
        ```

        Если `condition` истинно, выполняется `statement`.

    *   **`if-else` (полная форма):**

        ```csharp
        if (condition) statement1;
        else statement2;
        ```
    * **Пример if-else**
       ```csharp
        if (a > 0 || b<0) x=y;
        else x=z;
        ```

      Если `condition` истинно, выполняется `statement1`, иначе – `statement2`.

    *   **`switch`:** Многовариантное ветвление.

        ```csharp
        switch ( expression )
        {
         case constant_expression_1:
        [statement1]; <оператор перехода>;
         case constant_expression_2:
        [statement2]; <оператор перехода>;
         ...
         case constant_expression_n:
        [statement n]; <оператор перехода>;
         [default: statement; ]
        }
        ```

**4. Операторы цикла в C#.**

*   **`while` (с предусловием):**

    ```csharp
    while (condition) statement;
    ```

    `statement` выполняется, пока `condition` истинно.

*   **`do-while` (с постусловием):**

    ```csharp
    do statement while (condition);
    ```

    `statement` выполняется *сначала*, затем проверяется `condition`.

* **Пример do-while**
    ```csharp
    static void Main()
    {
      Console.Write("N= ");
      int n=int.Parse(Console.ReadLine());
      int i = 1;
      do
        Console.Write(" " + i++);
      while (i <= n)
    }
    ```
*   **`for` (с параметром):**

    ```csharp
    for ( initialization; condition; modification)
        statement;
    ```

    `initialization` выполняется один раз в начале. `condition` проверяется перед каждой итерацией. `modification` выполняется после каждой итерации.
*   **Пример for**

    ```csharp
    static void Main()
     {
      int n = 10;
      for (int i = 1; i <= n; i++)
        {
         Console.WriteLine(i);
         }
     }
    ```

*   **`foreach`** (для перебора элементов коллекции, в предоставленной информации не описан).

*   **Операторы безусловного перехода:**
    *   `goto label;`
    *   `break;` (выход из цикла или `switch`)
    *   `continue;` (переход к следующей итерации)

**5. Методы в C#.**

*   **Метод** – функциональный элемент класса, реализующий вычисления или действия. Представляет собой именованный блок кода.

*   **Синтаксис:**

    ```csharp
    [attributes] [modifiers] return_type method_name ([parameter_list])
    {
        method_body;
        return value;
    }
    ```

    *   `return_type`: Тип возвращаемого значения. Если метод ничего не возвращает, указывается `void`.
    *   `method_name`: Идентификатор.
    *   `parameter_list`: Список параметров (тип и идентификатор).
    *   `return value`: Возврат значения из метода.

*   **Перегрузка методов (Method Overloading):** Несколько методов с одним именем, но разными типами и/или количеством параметров. Выбор конкретного метода определяется типами и количеством аргументов при вызове.

*   **Пример:**
    ```csharp
    class MyClass
    {
       public int MyMethod(int a, int b) //Пример метода
      {
          return a+b;
      }
    }
    ```

**6. Работа с массивами.**

*   **Массив** — набор элементов одного и того же типа, объединенных общим именем. В C# массивы являются ссылочными типами (reference types) и реализованы как объекты.
*   **Одномерные массивы:**
    *   Объявление: `base_type[] array_name;`
        *   Пример: `int[] a;`
    *   Выделение памяти и инициализация: `array_name = new base_type[size];`
        *   Пример: `a = new int[10];`
    *   Объявление с инициализацией: `base_type[] array_name = { value1, value2, ... };`
        *   Пример: `int[] a = {0, 1, 2, 3};`
    *   Доступ к элементам: по индексу (начиная с 0).  Пример: `a[0] = 5;`
    *   Свойство `Length`: возвращает количество элементов в массиве.
    *   Пример работы с одномерным массивом
           ```csharp
           int[] a = new int[10]; //создается массив из 10 элементов
           a[0]=1; //присваиваем значение первому элементу массива
           ```

*   **Многомерные массивы:**
    *   Объявление: `base_type[,] array_name;` (для двумерного массива).
    *   Выделение памяти: `array_name = new base_type[size1, size2];`
    *   Объявление с инициализацией: `int[,] a = {{1, 2}, {3, 4}};`
    *   Доступ к элементам: `a[0, 1] = 5;`

* **Класс System.Array**
  Предоставляет полезные статические методы и свойства:
    *   Length
    *   BinarySearch()
    *   Clear()
    *   Copy()
    *   CopyTo()
    *   GetValue()
    *   IndexOf()
    *  LastIndexOf()
    *  Reverse()
    *  SetValue()
    *   Sort()

**7. Обработка исключений.**

*   Исключение – это объект, содержащий информацию о необычном программном событии.
*   Для обработки исключений используется конструкция `try-catch-finally`:

    ```csharp
    try
    {
        // Контролируемый блок кода
    }
    catch (ExceptionType1 ex1)
    {
        // Обработчик исключения типа ExceptionType1
    }
    catch (ExceptionType2 ex2)
    {
        // Обработчик исключения типа ExceptionType2
    }
    finally
    {
        // Блок, выполняемый в любом случае
    }
    ```

    *   **`try`:**  Содержит код, в котором может возникнуть исключение.
    *   **`catch`:**  Блоки обработки исключений. Может быть несколько блоков `catch` для разных типов исключений.
    *   **`finally`:**  Выполняется всегда, независимо от того, возникло исключение или нет.  Часто используется для освобождения ресурсов.

*   **Генерация исключений:**  Оператор `throw`.  Пример: `throw new Exception("Сообщение об ошибке");`

**8. Символы и строки в C#.**

*   **Символы (`char`):**
    *   Предназначены для хранения одиночных символов в кодировке Unicode.
    *   Соответствует классу `System.Char`.
    *   Примеры: `char c = 'A';` , `char b = '\x64';`

*   **Неизменяемые строки (`string`):**
    *   Предназначены для хранения последовательностей символов Unicode.
    *   Являются ссылочным типом.
    *   Соответствуют классу `System.String`.
    *   Строки неизменяемы (immutable).  Операции, изменяющие строку, на самом деле создают новую строку.
    *    Примеры создания строк:

       ```csharp
        string s;
        s="кол около колокола";
        s=new string (' ', 20);
        char [] a={'a', 'b', 'c', 'd', 'e'};
        string v=new string (a);
        string v=new string (a, 0, 2);
       ```

*   **Изменяемые строки (`StringBuilder`):**
    *   Класс `System.Text.StringBuilder` предназначен для эффективного изменения строк.
    * Пример:
        ```csharp
        StringBuilder sb = new StringBuilder("Hello");
        sb.Append(" World!");
        ```

**9. Классы. Основные понятия ООП. Данные класса: поля и константы.**

*   **Класс** – это обобщенное понятие, определяющее характеристики и поведение некоторого множества объектов, называемых *экземплярами класса*.
*   **Основные понятия ООП (упомянутые в файлах):**
    *   **Классы и объекты:** Класс – шаблон, объект – экземпляр класса.
    *   **Наследование:** Классы-потомки наследуют свойства и поведение классов-предков, могут их дополнять и изменять.
    * **Инкапсуляция**: сокрытие деталей реализации.
    *  **Полиморфизм**: возможность объектов с одинаковой спецификацией иметь различную реализацию.
*   **Данные класса:**
    *   **Поля (Fields):** Переменные, хранящие данные, относящиеся к объекту класса (или к классу, если поле `static`).
    *   **Константы (Constants):**  Именованные значения, которые не могут быть изменены. Объявляются с ключевым словом `const`.

        ```csharp
        class MyClass
        {
            public int myIntField; // Поле
            public string myStringField;
            public const double Pi = 3.14159; // Константа
        }
        ```

**10. Конструкторы класса. Деструкторы.**

*   **Конструкторы:**
    *   Специальные методы, предназначенные для инициализации объектов класса.
    *   Имя конструктора совпадает с именем класса.
    *   Не возвращают значение (даже `void`).
    *   Могут иметь параметры (перегрузка конструкторов).
    *   Если конструктор не определен явно, создается конструктор по умолчанию (без параметров).
    * Вызывается с помощью оператора `new`
    * **Пример конструктора**
    ```csharp
    class Demo
    {
        public int a;
        // Конструктор
        public Demo()
       {
        }
    }

    Demo a = new Demo();
    ```

*   **Деструкторы:**
    *   Специальные методы, вызываемые перед удалением объекта из памяти (сборщиком мусора).
    *   Имя деструктора: `~ClassName()`.
    *   Не имеют параметров и не возвращают значение.
    *   Используются для освобождения ресурсов, захваченных объектом.
    * Синтаксис:
       ```csharp
      [атрибуты] [extern] ~имя_класса()
        {
        тело_деструктора
        }
       ```

**11. Свойства, Индексаторы, Операции класса.**

*   **Свойства (Properties):**
    *   Предоставляют удобный и безопасный способ доступа к данным объекта (полям).
    *   Синтаксис:

        ```csharp
        [атрибуты] [спецификаторы] тип имя_свойства
        {
            [get код_доступа]  // Аксессор чтения
            [set код_доступа]  // Аксессор записи
        }
        ```

    *   Аксессор `get` возвращает значение свойства.
    *   Аксессор `set` устанавливает значение свойства (использует неявный параметр `value`).
    *   Может быть только `get` (свойство только для чтения) или только `set` (свойство только для записи).

*   **Индексаторы (Indexers):**
    *   Позволяют обращаться к элементам класса по индексу (как к элементам массива).
    *   Синтаксис:

        ```csharp
        [атрибуты] [спецификаторы] тип this [список_параметров]
        {
            [get код_доступа]
            [set код_доступа]
        }
        ```

    *   `this` используется вместо имени.
    *   `список_параметров` определяет индексы (обычно один целочисленный индекс, но могут быть и другие типы).

*   **Операции класса (Operator Overloading):**
    *   Позволяют переопределить поведение стандартных операторов (например, `+`, `-`, `*`, `==`, `!=`) для объектов класса.
    *   Описываются с помощью методов специального вида:

        ```csharp
        [ атрибуты] спецификаторы объявитель_операции
        {тело}

        public static DArray operator +(DArray x, int a) //пример
        ```
    *   Перегрузка операций делает код более интуитивно понятным, если семантика операции для класса ясна.

**12. Наследование в C#. Полиморфизм.**

*   **Наследование:**
    *   Механизм, позволяющий создавать новые классы (потомки) на основе существующих (предков).
    *   Потомки наследуют данные (поля) и поведение (методы) предков, могут добавлять новые члены и переопределять существующие.
    *   Синтаксис:

        ```csharp
        class DerivedClass : BaseClass
        {
            // ...
        }
        ```
    *   `class Daemon : Monster`

    *   В C# поддерживается одиночное наследование (один предок), но класс может реализовывать несколько интерфейсов.
    *   Конструкторы не наследуются. В производном классе должны быть свои конструкторы.
    *   Ключевое слово `base` используется для доступа к членам базового класса.

*   **Полиморфизм:**
    *   Способность объектов разных классов обрабатывать вызовы методов с одинаковыми именами по-разному, в соответствии со своим типом.
    *   Реализуется с помощью *виртуальных методов* (ключевое слово `virtual` в базовом классе и `override` в производном).
    * `virtual public void Passport()`
    * `override public void Passport()`

    *   Позднее связывание (Late Binding): выбор конкретного метода для вызова происходит во время выполнения программы, а не во время компиляции.
    *   Виртуальные методы базового класса определяют *интерфейс* всей иерархии.

**13. Интерфейсы в C#. Область применения интерфейсов. Интерфейсы и наследование.**

*   **Интерфейс:**
    *   Определяет контракт, который должны выполнять реализующие его классы.
    *   Содержит объявления методов, свойств, индексаторов и событий (без реализации).
    *   Синтаксис:

        ```csharp
        [ атрибуты ] [ спецификаторы ] interface имя_интерфейса [ : предки ]
         {
            тело_интерфейса [ ; ]
         }
        ```

    *   Все члены интерфейса по умолчанию `public`.
    *   Класс *реализует* интерфейс (указывается после двоеточия).

*   **Область применения:**
    *   Обеспечение полиморфизма: объекты разных классов, реализующих один интерфейс, могут обрабатываться единообразно.
    *   Определение общего поведения для несвязанных классов.

*   **Интерфейсы и наследование:**
    *   Интерфейс может наследовать другие интерфейсы.
    *   Класс может реализовывать несколько интерфейсов.
    *   При реализации интерфейса класс должен предоставить реализацию *всех* его членов.
    * Пример интерфейса
      ```csharp
      interface IAction
      {
       void Draw();
       int Attack(int a);
       void Die();
       int Power { get; }
      }
      ```

**14. Стандартные интерфейсы .NET**

*   Примеры стандартных интерфейсов:
    *   **`IComparable`:**  Определяет метод `CompareTo()` для сравнения объектов. Используется для сортировки.
    *   **`IEnumerable` / `IEnumerator`:**  Позволяют перебирать элементы коллекции (например, с помощью `foreach`).
    *   **`IDisposable`:**  Определяет метод `Dispose()` для освобождения ресурсов.
    *  **`IList`:**
        * Add()
        * Clear()
        * Contains()
        * IndexOf()
        * Insert()
        * Remove()
        * RemoveAt()
    *   **`ICollection`**
        *CopyTo()
        *GetEnumerator()
        *Count

**15. Делегаты и события в C#.**

*   **Делегат:**
    *   Тип, представляющий собой ссылку на метод.
    *   Позволяет передавать методы как параметры другим методам (обратные вызовы, callbacks).
    *   Синтаксис объявления:

        ```csharp
        [атрибуты] [спецификаторы] delegate  тип имя_делегата  ( [ параметры ]  )
        ```
    * Пример:
      `public delegate void Del();`

*   **Событие:**
    *   Механизм уведомления объектов о происходящих действиях.
    *   Основаны на делегатах.
    *   Класс, генерирующий событие, называется *издателем (publisher)*, а класс, обрабатывающий событие, – *подписчиком (subscriber)*.
    *   Синтаксис объявления:

        ```csharp
        [ атрибуты ] [ спецификаторы ] event тип имя_события
        ```

    * Пример
     ```csharp
        public event Del Oops;
      ```

    *   Для подписки на событие используется оператор `+=`, для отписки – `-=`.

    * **Пример подписки на событие**

     ```csharp
     s.Oops += new Del( o1.Do );
     s.Oops += new Del( o2.Do );
     s.Oops += new Del( ObsB.See );
     ```

    В данном примере к событию Oops присоединяются методы Do, Do, See.

    *   Обработчик события имеет сигнатуру, соответствующую делегату, на котором основано событие.  Часто используется стандартный делегат `EventHandler`:
      ``` csharp
       public delegate void EventHandler(object sender, EventArgs e);
      ```

    *   `sender` – объект, сгенерировавший событие.
    *   `e` – объект, содержащий информацию о событии (наследник `EventArgs`).

    *   **Пример объявления события и обработчика**

    ```csharp
    // Объявление делегата
     public delegate void MyEventHandler(object sender, EventArgs e);
     public class MyClass
      {
         // Объявление события
         public event MyEventHandler MyEvent;
         // Метод, инициирующий событие
          protected virtual void OnMyEvent(EventArgs e)
            {
              MyEvent?.Invoke(this, e); // Проверка на null и вызов события
            }
             // Обработчик события
            public void MyEventHandler(object sender, EventArgs e)
             {
               // Обработка события
             }
       }
    ```

**16. Обобщения (Generics)**

*   Обобщения (Generics) позволяют создавать классы, структуры, интерфейсы и методы, в которых типы данных, используемые этими элементами, параметризованы.  Это означает, что вы можете определить класс или метод, который работает с *любым* типом, не указывая конкретный тип заранее.
*   Типы-параметры указываются в угловых скобках `<T>`, `<T1, T2>`, и т.д.  `T` – это общепринятое обозначение, но можно использовать и другие идентификаторы.
* **Пример обобщенного класса:**

    ```csharp
    public class MyList<T>
    {
        private T[] items;
        private int count;

        public MyList()
        {
            items = new T[10];
            count = 0;
        }

        public void Add(T item)
        {
            items[count] = item;
            count++;
        }

        public T Get(int index)
        {
            return items[index];
        }
    }
    ```

  В этом примере `MyList<T>` может хранить элементы *любого* типа `T`. При создании экземпляра класса указывается конкретный тип:

    ```csharp
    MyList<string> stringList = new MyList<string>();
    stringList.Add("Hello");
    string s = stringList.Get(0);

    MyList<int> intList = new MyList<int>();
    intList.Add(10);
    int i = intList.Get(0);

    ```

*   **Обобщенные методы:**

    ```csharp
    public class MyClass
    {
        public T GenericMethod<T>(T arg)
        {
            return arg;
        }
    }
    ```

    ```csharp
    MyClass myClass = new MyClass();
    int result1 = myClass.GenericMethod<int>(5); // Явное указание типа
    string result2 = myClass.GenericMethod("abc");   // Тип выводится компилятором
    ```

*   **Ограничения (Constraints):**  Можно накладывать ограничения на типы-параметры, указывая, какие интерфейсы они должны реализовывать, каким базовым классом обладать, иметь конструктор по умолчанию, быть ссылочным типом или типом-значением.  Используется ключевое слово `where`.

    ```csharp
    public class MyClass<K, T>
        where K : IComparable<K>, new() // K должен реализовывать IComparable<K> и иметь конструктор без параметров
        where T : class             // T должен быть ссылочным типом
    {
        // ...
    }
    ```

*  **Пример с ограничениями**
    ```csharp
    class MyGenericClass <K,T> where K : MyBaseClass, IComparable<K>
     where T : ICloneable, IDisposable
    {...}
    ```
   В данном примере говорится о том, что K должен быть наследником MyBaseClass и реализовывать интерфейс IComparable<K>, T должен реализовывать интерфейсы ICloneable, IDisposable

* **Nullable<T>:** Позволяет типам значений принимать значение `null`.
* **Оператор default(T)** возвращает null для ссылочных типов, и 0 для значимых.

**17. Рефлексия типов и программирование с использованием атрибутов**

*   **Рефлексия (Reflection):**  Механизм, позволяющий получать информацию о типах (классах, интерфейсах, структурах, методах, свойствах и т.д.) *во время выполнения* программы.
*   **Пространство имен:**  `System.Reflection`.
*   **Класс `Type`:**  Центральный класс рефлексии.  Представляет описание типа.  Получить объект `Type` можно несколькими способами:
    *   `Type t = typeof(MyClass);`  // Используем оператор `typeof`
    *   `object obj = new MyClass(); Type t = obj.GetType();` // Используем метод `GetType()`, унаследованный от `object`
    *   `Type t = Type.GetType("MyNamespace.MyClass");` // По строковому имени типа

*   **Члены класса `Type` (примеры):**
    *   `IsAbstract`, `IsArray`, `IsClass`, `IsInterface`:  Проверка характеристик типа.
    *   `GetMembers()`, `GetMethods()`, `GetProperties()`, `GetFields()`, `GetConstructors()`: Получение информации о членах типа.
    *   `FullName`, `BaseType`:  Полное имя типа, базовый тип.
    *   `InvokeMember()`: Позднее связывание (вызов метода по имени во время выполнения).

*   **Атрибуты (Attributes):**
    *   Механизм добавления метаданных (дополнительной информации) к коду (классам, методам, свойствам и т.д.).
    *   Атрибуты заключаются в квадратные скобки: `[AttributeName]`
    *   Примеры встроенных атрибутов: `[Serializable]`, `[Obsolete]`, `[DllImport]`.
    *   Можно создавать собственные атрибуты, наследуя от `System.Attribute`.
    *   Пример использования атрибутов:
    ``` csharp
    // Этот класс можно сохранять на диске
    [Serializable]
    public class Motorcycle
    {
     bool hasRadioSystem;
     bool hasHeadSet;
     bool hasBar;
     
     // Однако незачем утруждать себя сохранением этого поля
      [NonSerialized]
     float weightOfCurrentPassangers;
    }
    ```

    *  Пример создания пользовательского атрибута

       ```csharp
        public class VehicleDescriptionAttribute : System.Attribute
        {
         private string description;
         public string Desc
        {
        get { return description; }
        set { description = value; }
        }
         public VehicleDescriptionAttribute() {}
         public VehicleDescriptionAttribute(string desc) 
         { description = desc;}
        }
       ```

**18. Типы пользовательских интерфейсов. Пространство имен System.Windows.Forms.**

*   **Типы пользовательских интерфейсов:**
    *   **Консольные приложения (Console Applications):**  Взаимодействие с пользователем через текстовый ввод/вывод в консольном окне.
    *   **Windows Forms Applications:**  Приложения с графическим интерфейсом (GUI), использующие окна, элементы управления (кнопки, текстовые поля, списки и т.д.).
    *  **Web Applications**: Веб-приложения.
    * **WPF Applications:** Более современная технология для создания GUI, чем Windows Forms.

*   **`System.Windows.Forms`:**  Пространство имен, содержащее классы для создания Windows Forms приложений.
* **Основные классы:**
    *  `Form`:  Базовый класс для окон приложений.
    *  `Control`:  Базовый класс для элементов управления (кнопок, текстовых полей и т.д.).
    *  `Application`:  Класс, управляющий приложением (запуск, обработка сообщений).
    *  `Button`, `Label`, `TextBox`, `ListBox`, `CheckBox`, `RadioButton`, `PictureBox`, `MenuStrip`, `ToolStrip`, `StatusStrip`, `ContextMenuStrip`, `Timer`, `OpenFileDialog`, `SaveFileDialog`, `DataGridView` и многие другие – классы элементов управления.

**19. Типы окон. Графический интерфейс форм.**

*   **Типы окон:**
    *   **Основное окно (Main Form):**  Главное окно приложения.
    *   **Диалоговые окна (Dialog Boxes):**  Используются для взаимодействия с пользователем (ввод данных, вывод сообщений).  Могут быть стандартными (MessageBox) и пользовательскими.
    *   **Дочерние окна (Child Windows):**  Окна, размещаемые внутри других окон (часто элементы управления).

*   **Графический интерфейс форм:**  Формы (Form) – это окна приложений.  Они содержат элементы управления (Controls), с помощью которых пользователь взаимодействует с программой.

*   **Основные элементы интерфейса формы:**
    *   **Строка заголовка (Title Bar):**  Содержит заголовок окна и кнопки управления окном (свернуть, развернуть, закрыть).
    *   **Меню (Menu):**  Организованный набор команд.
    *   **Панели инструментов (Toolbars):**  Содержат кнопки и другие элементы управления для быстрого доступа к командам.
    *   **Строка состояния (Status Bar):**  Отображает информацию о состоянии приложения.
    *   **Клиентская область (Client Area):**  Область, в которой размещаются элементы управления и выводится содержимое окна.

**20. Основные элементы интерфейса окна программы.**

*   **Меню (Menu):**  Иерархическая структура команд, доступных пользователю.
    *   `MenuStrip`:  Главное меню приложения.
    *   `ToolStripMenuItem`:  Отдельный пункт меню.
    *   `ContextMenuStrip`:  Контекстное меню (появляется при щелчке правой кнопкой мыши).

*   **Панели инструментов (Toolbars):**  Содержат кнопки и другие элементы управления для быстрого доступа к командам.
    *   `ToolStrip`:  Панель инструментов.
    *   `ToolStripButton`:  Кнопка на панели инструментов.
    *   `ToolStripLabel`:  Метка на панели инструментов.
    *  `ToolStripDropDownButton`: Выпадающий список.
    *  `ToolStripSplitButton`
    *  `ToolStripSeparator`: Разделитель.
    *  `ToolStripTextBox`: Текстовое поле
    *  `ToolStripProgressBar`

*   **Строка состояния (Status Bar):**  Отображает информацию о состоянии приложения, ходе выполнения операций и т.д.
    *   `StatusStrip`
        *`ToolStripStatusLabel`
    * `ToolStripProgressBar`

* **Элементы управления**
    * `Label` (метки)
    * `LinkLabel` (метки)
    * `Button` (кнопки)
    * `RadioButton` (кнопки)
    *  `CheckBox`(флажки)
    *  `CheckedListBox` (флажки)
    * `ListBox` (флажки)
    * `ListView` (списки)
    * `ComboBox` (списки)
    * `TextBox` (текст)
    *  `RichTextBox` (текст)
    *  `MaskedTextBox` (текст)
    *  `NotifyIcon`
    *  `NumericUpDown`
    *  `PictureBox` (графика)
    *  `ProgressBar`
    * `ToolTip`
    *  `TreeView` (дерево)
    * `WebBrowser`
    * `DateTimePicker`
    * `MonthCalendar`

**21. Меню. Инструментальные полосы. Полосы состояния.**

*   **Меню (Menus):**
    *   **`MenuStrip`:**  Основной класс для создания главного меню приложения (горизонтальная полоса в верхней части окна).
    *   **`ToolStripMenuItem`:**  Представляет отдельный пункт меню (или подменю).  Может содержать текст, изображение, флажок (checked state) и сочетание клавиш быстрого доступа (shortcut).
    *   **`ContextMenuStrip`:**  Контекстное меню, появляющееся при щелчке правой кнопкой мыши.  Привязывается к элементу управления через свойство `ContextMenuStrip`.
    * Структура меню строится иерархически: `MenuStrip` содержит коллекцию `Items` (объекты `ToolStripMenuItem`), а каждый `ToolStripMenuItem` может иметь свою коллекцию `DropDownItems` (тоже объекты `ToolStripMenuItem`).

*   **Инструментальные полосы (Toolbars):**
    *   **`ToolStrip`:**  Контейнер для элементов управления, обычно кнопок, предоставляющих быстрый доступ к командам приложения.
    *   **`ToolStripButton`:**  Кнопка на панели инструментов.
    *   **`ToolStripLabel`:**  Метка на панели инструментов.
    *   **`ToolStripSeparator`:**  Разделитель между элементами.
    *   **`ToolStripComboBox`:**  Раскрывающийся список.
    *   **`ToolStripTextBox`:** Текстовое поле.
    *   **`ToolStripProgressBar`:** Индикатор прогресса.
    * `ToolStripSplitButton`
    *  `ToolStripDropDownButton`

*   **Полосы состояния (Status Bars):**
    *   **`StatusStrip`:**  Горизонтальная полоса в нижней части окна, отображающая информацию о состоянии приложения.
    *   **`ToolStripStatusLabel`:**  Метка для отображения текста в строке состояния.
    *   **`ToolStripProgressBar`:**  Индикатор прогресса в строке состояния.

*  **Примеры:**
    *  Создание пункта меню и добавление обработчика для события Click:
        ```csharp
        ToolStripMenuItem miClose = new ToolStripMenuItem();
        miClose.Text = "Close";
        miClose.Click += new EventHandler(CloseOnClick);

        // ...

        public void CloseOnClick(object sender, EventArgs e)
        {
             //Действия
        }
        ```

**22. Элементы управления. Компоненты.**

*   **Элементы управления (Controls):**  Визуальные компоненты, обеспечивающие взаимодействие пользователя с приложением (кнопки, текстовые поля, списки и т.д.).  Наследуются от класса `System.Windows.Forms.Control`.

*   **Компоненты (Components):**  Невизуальные элементы, предоставляющие функциональность приложению (например, `Timer`, `ImageList`).

* **Примеры элементов управления, упомянутых в файлах:**

    *   `Label`: Метка (статический текст).
    *   `LinkLabel`: Метка-ссылка.
    *   `Button`: Кнопка.
    *   `TextBox`: Текстовое поле (однострочное).
    *    `RichTextBox`: Текстовое поле с форматированием.
    *   `MaskedTextBox`: Текстовое поле с маской ввода.
    *   `CheckBox`: Флажок (checkbox).
    *   `RadioButton`: Переключатель (radio button).
    *   `ListBox`: Список (одно- или многострочный).
    *   `CheckedListBox`: Список с флажками.
    *   `ComboBox`: Раскрывающийся список.
    *   `PictureBox`: Отображение изображений.
    *   `ProgressBar`: Индикатор прогресса.
    *   `TreeView`: Древовидное представление данных.
    *  `DateTimePicker`: Элемент для ввода даты и времени.
    *   `MonthCalendar`: Календарь.
    *   `NotifyIcon`
    *   `NumericUpDown`
    *    `ToolTip`
    *   `WebBrowser`: Элемент управления для отображения веб-страниц.
    * `GroupBox`: контейнер
    * `Panel`: контейнер
    * `SplitContainer` :контейнер
    * `TabControl` : контейнер

* **Примеры компонентов, упомянутых в файлах**
    * Timer
    * ImageList
    * OpenFileDialog, SaveFileDialog (хотя явно не указаны, подразумеваются как "общие диалоги")

**23. Основные события классов элементов.**

*   **Общие события:**
    *   `Click`:  Происходит при щелчке (левой кнопкой мыши или нажатии клавиши `Space` для кнопок).
    *   `MouseEnter`, `MouseLeave`, `MouseDown`, `MouseUp`, `MouseMove`, `MouseHover`, `MouseWheel`:  События мыши.
    *   `KeyDown`, `KeyUp`, `KeyPress`:  События клавиатуры.
    *   `Paint`:  Происходит, когда элемент управления должен быть перерисован.
    *    `GotFocus`
    *   `LostFocus`
*   **Специфические события:**
    *   `TextChanged` (для `TextBox`, `RichTextBox` и других текстовых элементов):  Происходит при изменении текста.
    *   `SelectedIndexChanged` (для `ListBox`, `ComboBox`):  Происходит при изменении выбранного элемента.
    *   `CheckedChanged` (для `CheckBox`, `RadioButton`):  Происходит при изменении состояния флажка/переключателя.
    *   `Scroll` (для полос прокрутки):  Происходит при прокрутке содержимого.
    * `Tick` у `Timer`
    * `DateChanged` у `MonthCalendar`

**24. Наследственность класса Form.**

*   Класс `Form` является производным от `System.Windows.Forms.Control` (через промежуточные классы `ContainerControl`, `ScrollableControl`).
    ```
    Object
    ...
    Control
      ScrollableControl
         ContainerControl
            Form
    ```
*   Это означает, что `Form` наследует все свойства, методы и события класса `Control` (и его предков).
*  `Form` расширяет базовый класс, добавляя функциональность, специфичную для окон верхнего уровня (главных окон приложений, диалоговых окон).
*   При создании формы в Visual Studio, как правило, создается класс, производный от `Form`.

**25. Работа с внешними устройствами.**

В предоставленных файлах *прямо* не описана работа с внешними устройствами.  Есть лишь косвенные упоминания:

*   **Дисплей:** Описывается структура дисплея (пиксели, разрешение), система координат, используемая для рисования.  Класс `Graphics` предоставляет методы для рисования на поверхности окна (которое, в конечном счете, отображается на дисплее).
*   **Клавиатура и мышь:** Упоминаются события, связанные с клавиатурой и мышью (`KeyDown`, `KeyUp`, `KeyPress`, `Click`, `MouseDown`, `MouseUp` и т.д.).  Это *ввод* с внешних устройств.
*   **Принтер:**  Упоминается пространство имен `System.Drawing.Printing`, содержащее классы для вывода на принтер, а также упоминается в контексте GDI+.  Есть упоминание классов `PrintDialog`, `PageSetupDialog`, `PrintDocument`, `PrintPreviewDialog`, `PrintPreviewControl`.
* **Файлы**: упоминаются классы для работы с файловой системой.

**26. Класс Graphics. Инструменты рисования. Перо. Кисть. Шрифт.**

*   **Класс `Graphics`:**
    *   Основной класс для рисования в Windows Forms.  Представляет собой *контекст устройства* (device context), то есть абстракцию, позволяющую рисовать на различных поверхностях (окно, принтер, метафайл).
    *   Находится в пространстве имен `System.Drawing`.
    *   Нельзя создать экземпляр `Graphics` с помощью `new`.  Его получают:
        *   В обработчике события `Paint` через аргумент `PaintEventArgs` (`e.Graphics`).
        *   Вызовом метода `CreateGraphics()` у объекта `Control` (например, формы `this.CreateGraphics()`).
        * Важно! После использования объект `Graphics` ,полученный через CreateGraphics(), нужно освобождать. Пример :
            ```csharp
            Graphics gfx = frm.CreateGraphics();
            //действия по рисованию
            gfx.Dispose();
            ```
    *   Предоставляет методы для рисования линий, фигур, текста, изображений.

*   **Инструменты рисования:**
    *   **Перо (`Pen`):**  Определяет параметры линии (цвет, толщину, стиль).
        *   Класс `System.Drawing.Pen`.
        *   Конструкторы: `Pen(Color)`, `Pen(Color, float width)`.
        *   Свойство `DashStyle` задает стиль линии (сплошная, пунктирная и т.д.).
        *   Статический класс `Pens` содержит предопределенные перья разных цветов.
        ``` csharp
        Pen myPen = new Pen(Color.Red, 3); // Красное перо, толщина 3
        Pen myPen = new Pen(Color.Red); // Красное перо, толщина 1 (по умолчанию)
        ```
    *   **Кисть (`Brush`):**  Определяет параметры заливки замкнутых фигур.
        *   Абстрактный класс `System.Drawing.Brush`.
        *   Производные классы:
            *   `SolidBrush`:  Заливка сплошным цветом.
            *   `HatchBrush`:  Заливка штриховкой.
            *   `TextureBrush`:  Заливка изображением.
            *   `LinearGradientBrush`:  Градиентная заливка.
        *   Статический класс `Brushes` содержит предопределенные кисти разных цветов.

    *   **Шрифт (`Font`):**  Определяет параметры текста (гарнитура, размер, начертание).
        *   Класс `System.Drawing.Font`.
        *   Конструкторы: `Font(string familyName, float emSize)`, `Font(string familyName, float emSize, FontStyle style)` и другие.
        *   `FontStyle`: перечисление, определяющее начертание (Regular, Bold, Italic, Underline, Strikeout).

        ```csharp
          Font fnt = new Font("Arial", 12, FontStyle.Bold | FontStyle.Italic);
        ```

**27. Рисование фигур**

*   Класс `Graphics` предоставляет методы для рисования различных фигур:
    *   **Линии:**
        *   `DrawLine(Pen pen, Point pt1, Point pt2)`
        *   `DrawLine(Pen pen, int x1, int y1, int x2, int y2)`
        *   `DrawLines(Pen pen, Point[] points)`

    *   **Прямоугольники:**
        *   `DrawRectangle(Pen pen, Rectangle rect)`
        *   `DrawRectangle(Pen pen, int x, int y, int width, int height)`
        *   `DrawRectangles(Pen pen, Rectangle[] rects)`
        *   `FillRectangle(Brush brush, Rectangle rect)` // Закрашенный прямоугольник

    *   **Эллипсы:**
        *   `DrawEllipse(Pen pen, Rectangle rect)`
        *   `DrawEllipse(Pen pen, int x, int y, int width, int height)`
        *  `FillEllipse(Brush brush, Rectangle rect)`

    *   **Многоугольники:**
        *   `DrawPolygon(Pen pen, Point[] points)`
        *   `FillPolygon(Brush brush, Point[] points)`
    *  **Дуги и сектора**
        * `DrawArc`
        * `DrawPie`
        * `FillPie`

    *   **Кривые:**
        *   `DrawCurve(...)`

**28. Работа с изображениями.**

*   **Класс `Image`:**  Абстрактный базовый класс для работы с изображениями.  Наследники: `Bitmap`, `Metafile`.
*   **Класс `Bitmap`:**  Представляет растровое изображение.
    * Загрузка из файла
    ``` csharp
    Image image = Image.FromFile("image.png");
    Bitmap bmp = new Bitmap("image.jpg");
    ```
    *   Рисование изображения:
        *   `DrawImage(Image image, Point point)`
        *   `DrawImage(Image image, int x, int y)`
        *   `DrawImage(Image image, Rectangle rect)` и другие перегрузки.
    *   Сохранение:
     ```csharp
      bmp.Save("filename.jpg", 
    System.Drawing.Imaging.ImageFormat.Jpeg);
     ```

**29. Введение в работу с базами данных. Основы ADO.Net.**

*   **База данных (Database):**  Организованный набор структурированных данных, обычно хранящихся в электронном виде.
*   **Система управления базами данных (СУБД, DBMS):**  Программное обеспечение, позволяющее создавать, управлять и получать доступ к базам данных.
*   **ADO.NET:**  Набор классов .NET Framework, предоставляющих службы доступа к данным.  Позволяет взаимодействовать с различными источниками данных (базы данных, XML-файлы и т.д.).
* **Основные компоненты ADO.NET:**
    *   **Data Providers (Поставщики данных):**  Наборы классов, специфичные для конкретного источника данных (например, SQL Server, Oracle, ODBC, OLE DB).  Обеспечивают подключение, выполнение команд, чтение результатов.
    *   **DataSet:**  Отсоединенное (disconnected) представление данных в памяти.  Может содержать несколько таблиц (`DataTable`) и отношения между ними (`DataRelation`).  Работает независимо от источника данных.

**30. Технологии Microsoft для работы с БД. Провайдеры данных ADO.NET.**

*   **Исторические технологии (упомянутые в файлах, но не являющиеся основной темой):**
    *   **ODBC (Open Database Connectivity):**  Стандартный API для доступа к базам данных.  Использует драйверы ODBC.
    *   **OLE DB (Object Linking and Embedding, Database):**  COM-based API для доступа к различным источникам данных (не только реляционным).
    *   **ADO (ActiveX Data Objects):**  COM-based библиотека, упрощающая работу с OLE DB.

*   **ADO.NET Data Providers:**
    *   **`System.Data.SqlClient`:**  Для работы с Microsoft SQL Server.  Классы: `SqlConnection`, `SqlCommand`, `SqlDataReader`, `SqlDataAdapter` и т.д.
    *   **`System.Data.OleDb`:**  Для работы с источниками данных, поддерживающими OLE DB.  Классы: `OleDbConnection`, `OleDbCommand`, `OleDbDataReader`, `OleDbDataAdapter` и т.д.
    *   **`System.Data.Odbc`:**  Для работы с источниками данных, поддерживающими ODBC. Классы: `OdbcConnection`, `OdbcCommand`, `OdbcDataReader`, `OdbcDataAdapter` и т.д.
    *  **`System.Data.OracleClient`**:  Для работы с базами данных Oracle.
* **Основные классы провайдеров данных**
    * `Connection`
    * `Command`
    * `DataReader`
    * `DataAdapter`

    
**31. Отсоединенный режим работы с БД. Использование классов ADO.NET.**

*   **Отсоединенный режим (Disconnected Mode):**  Программа получает данные из базы данных, сохраняет их в локальном кэше (например, в объекте `DataSet`), работает с этими данными, а затем, при необходимости, отправляет изменения обратно в базу данных.
*   **Преимущества:**
    *   Снижение нагрузки на сервер БД.
    *   Повышение производительности (особенно при большом количестве пользователей).
    *   Возможность работы с данными при отсутствии подключения к БД.
*   **Основные классы для отсоединенного режима:**
    *   `DataSet`:  Представляет собой кэш данных в памяти, состоящий из одной или нескольких таблиц (`DataTable`) и отношений между ними (`DataRelation`).  По сути, это мини-база данных в памяти приложения.
    *   `DataAdapter`:  Действует как мост между `DataSet` и источником данных.  Использует объекты `Command` (`SelectCommand`, `InsertCommand`, `UpdateCommand`, `DeleteCommand`) для извлечения данных из БД и сохранения изменений в БД.

*   **Схема работы:**
    1.  Создание `DataAdapter` и настройка его команд (`SelectCommand` и, при необходимости, `InsertCommand`, `UpdateCommand`, `DeleteCommand`).
    2.  Создание `DataSet`.
    3.  Заполнение `DataSet` данными с помощью метода `Fill()` объекта `DataAdapter`.
    4.  Работа с данными в `DataSet` (просмотр, изменение, добавление, удаление).
    5.  Отправка изменений в БД с помощью метода `Update()` объекта `DataAdapter`.

**32. Основные методы выполнения Command.**

Класс `Command` предоставляет методы для выполнения команд SQL (или хранимых процедур) по отношению к базе данных.  Есть три основных метода:

*   **`ExecuteReader()`:**
    *   Используется для выполнения запросов, возвращающих *набор данных* (например, `SELECT`).
    *   Возвращает объект `DataReader`, который позволяет построчно читать результаты запроса.
    *   Работает в *подключенном* режиме (connected mode).

*   **`ExecuteNonQuery()`:**
    *   Используется для выполнения команд, которые *не возвращают* набора данных (например, `INSERT`, `UPDATE`, `DELETE`, `CREATE TABLE`).
    *   Возвращает количество затронутых строк (или -1, если команда не изменила данные).

*   **`ExecuteScalar()`:**
    *   Используется для выполнения запросов, возвращающих *одно значение* (скаляр). Например, запросы, использующие агрегатные функции `COUNT`, `SUM`, `AVG`, `MIN`, `MAX`.
    *   Возвращает первый столбец первой строки результирующего набора.

**33. Класс DataReader.**

*   **`DataReader`:**  Предоставляет быстрый, последовательный, *только для чтения* доступ к данным, полученным в результате выполнения команды `SELECT`.
*   Работает в *подключенном* режиме (требуется открытое соединение с БД).
*   **Основные методы:**
    *   `Read()`:  Перемещается к следующей записи в результирующем наборе.  Возвращает `true`, если запись доступна, и `false`, если достигнут конец набора.
    *   `[index]` (индексатор):  Получение значения поля текущей записи по индексу столбца (или по имени столбца).
    *   `Close()`:  Закрывает `DataReader`.

*   **Пример использования:**

    ```csharp
    // Предполагается, что connection и command уже настроены
    SqlDataReader reader = command.ExecuteReader();

    while (reader.Read())
    {
        Console.WriteLine(reader[0] + " " + reader["ColumnName"]);
        // или
        // Console.WriteLine(reader.GetInt32(0) + " " + reader.GetString(1));
    }

    reader.Close();
    ```

**34. Вызов хранимых процедур.**

*   Хранимые процедуры (Stored Procedures) – это предварительно скомпилированные наборы операторов SQL, хранящиеся на сервере БД.
*   **Преимущества:**
    *   Повышение производительности (процедура компилируется один раз).
    *   Улучшение безопасности (можно ограничить доступ к таблицам, разрешив выполнение только хранимых процедур).
    *   Уменьшение сетевого трафика (вместо текста запроса передается только имя процедуры и параметры).

*   **Вызов хранимой процедуры с помощью ADO.NET:**
    1.  Создать объект `Command`.
    2.  Установить свойство `CommandType` в `CommandType.StoredProcedure`.
    3.  Установить свойство `CommandText` равным имени хранимой процедуры.
    4.  При необходимости, добавить параметры с помощью коллекции `Parameters` объекта `Command`.
    5.  Выполнить процедуру с помощью одного из методов `Execute...` (`ExecuteReader`, `ExecuteNonQuery`, `ExecuteScalar`).

*   **Пример:**

    ```csharp
    // Предполагается, что connection уже настроен
    SqlCommand command = new SqlCommand("MyStoredProcedure", connection);
    command.CommandType = CommandType.StoredProcedure;

    // Добавление входного параметра
    SqlParameter param1 = new SqlParameter("@Param1", SqlDbType.Int);
    param1.Value = 10;
    command.Parameters.Add(param1);
    //или
    //command.Parameters.AddWithValue("@Param1", 10);

    // Добавление выходного параметра
    SqlParameter param2 = new SqlParameter("@OutputParam", SqlDbType.VarChar, 50);
    param2.Direction = ParameterDirection.Output; // Важно!
    command.Parameters.Add(param2);

    // Выполнение
    command.ExecuteNonQuery();

    // Получение выходного параметра
    string outputValue = (string)param2.Value;
    ```

**35. Класс DataSet. Внутреннее устройство DataSet. Связь класса DataSet с другими классами. Основные методы DataSet.**

*   **`DataSet`:**  Представляет собой кэш данных в памяти, *отсоединенный* от источника данных.  По сути, это мини-база данных в памяти приложения.
*   **Внутреннее устройство:**
    *   **`Tables`:**  Коллекция объектов `DataTable`, представляющих таблицы данных.
    *   **`Relations`:**  Коллекция объектов `DataRelation`, определяющих отношения между таблицами (связи "один-ко-многим").
    * В свою очередь `DataTable` содержит:
        * `Columns`: коллекция объектов  DataColumn
        * `Rows`: коллекция объектов  DataRow
        *  DefaultView
    *  **Пример структуры:**

        ```
        DataSet
        ├── Tables (DataTableCollection)
        │   ├── DataTable ("Customers")
        │   │   ├── Columns (DataColumnCollection)
        │   │   │   ├── DataColumn ("CustomerID")
        │   │   │   ├── DataColumn ("CompanyName")
        │   │   │   └── ...
        │   │   └── Rows (DataRowCollection)
        │   │       ├── DataRow
        │   │       ├── DataRow
        │   │       └── ...
        │   ├── DataTable ("Orders")
        │   │   └── ...
        │   └── ...
        └── Relations (DataRelationCollection)
            └── DataRelation ("FK_Orders_Customers")

        ```

*   **Связь с другими классами:**
    *   `DataAdapter`:  Используется для заполнения `DataSet` данными из источника данных и для сохранения изменений обратно в источник данных.
    *   `DataTable`:  Представляет таблицу данных.
    *   `DataRow`:  Представляет строку данных в таблице.
    *   `DataColumn`:  Представляет столбец в таблице.
    *   `DataRelation`:  Определяет отношение (связь) между двумя таблицами.
    * `DataView`:  Предоставляет представление данных из `DataTable` (сортировка, фильтрация).

*   **Основные методы `DataSet`:**
    *   `Fill()`  (методы `DataAdapter`): Заполняет `DataSet` данными.
    *   `Update()` (методы `DataAdapter`): Сохраняет изменения в источник данных.
    *   `Merge()`:  Объединяет данные из другого `DataSet`.
    *   `AcceptChanges()`:  Фиксирует изменения в `DataSet`.
    *   `RejectChanges()`:  Отменяет изменения.
    *   `Clear()`: Очищает все таблицы.
    *   `GetXml()`, `GetXmlSchema()`: Получение данных и схемы в формате XML.
    *   `ReadXml()`, `ReadXmlSchema()`: Загрузка данных и схемы из XML.
    *   `WriteXml()`, `WriteXmlSchema()`: Запись данных и схемы в XML.

* **Пример**
```csharp
    DataSet pubsDataSet = new DataSet("Pubs");
```
В данном примере создается объект класса DataSet.
